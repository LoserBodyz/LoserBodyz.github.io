<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>着色器基础-01</title>
      <link href="/2024/12/09/zhao-se-qi-ji-chu-01/"/>
      <url>/2024/12/09/zhao-se-qi-ji-chu-01/</url>
      
        <content type="html"><![CDATA[<h2 id="着色器-shader"><a href="#着色器-shader" class="headerlink" title="着色器(shader)"></a>着色器(shader)</h2>]]></content>
      
      
      
        <tags>
            
            <tag> -UNITY </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于柏林噪声的基础</title>
      <link href="/2024/12/06/guan-yu-bo-lin-zao-sheng-de-ji-chu/"/>
      <url>/2024/12/06/guan-yu-bo-lin-zao-sheng-de-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="柏林噪声（Perlin-Noise）"><a href="#柏林噪声（Perlin-Noise）" class="headerlink" title="柏林噪声（Perlin Noise）"></a>柏林噪声（Perlin Noise）</h1><p><strong>柏林噪声（Perlin Noise）</strong> 是一种常用的渐变噪声算法，广泛应用于游戏开发中，尤其是在程序生成内容（如随机地图、地形生成、纹理生成等）时。它由计算机图形学家 Ken Perlin 在 1983 年发明，目的是为了解决传统随机噪声（如白噪声）看起来不自然的问题。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h3 id="1-1-柏林噪声的特点"><a href="#1-1-柏林噪声的特点" class="headerlink" title="1.1 柏林噪声的特点"></a>1.1 柏林噪声的特点</h3><ol><li><strong>平滑渐变</strong>：生成的噪声没有突兀的跳跃，适合模拟自然现象，如山脉、云层。</li><li><strong>伪随机性</strong>：噪声看似随机，但可以通过种子值生成相同的噪声序列，确保可重复性。</li><li><strong>多维噪声</strong>：支持二维（地形）、三维（体积数据）、四维（动态效果）等不同维度的噪声。</li></ol><h3 id="1-2-在游戏开发中的应用"><a href="#1-2-在游戏开发中的应用" class="headerlink" title="1.2 在游戏开发中的应用"></a>1.2 在游戏开发中的应用</h3><ol><li><strong>地形生成</strong>：生成自然的山脉、平原、海洋等地貌。</li><li><strong>纹理生成</strong>：创建无缝纹理，如云彩、岩石、草地等。</li><li><strong>程序生成内容</strong>：用于随机生成森林、迷宫、关卡等。</li><li><strong>动态效果</strong>：如动态天气、云层运动等。</li></ol><h3 id="1-3-柏林噪声的优势"><a href="#1-3-柏林噪声的优势" class="headerlink" title="1.3 柏林噪声的优势"></a>1.3 柏林噪声的优势</h3><ul><li><strong>自然感</strong>：比传统随机噪声更自然、平滑。</li><li><strong>控制性</strong>：可以调整噪声的频率、振幅来控制细节和变化幅度。</li></ul><h2 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2. 基本原理"></a>2. 基本原理</h2><p>柏林噪声的实现基于 <strong>格点插值</strong>。</p><h3 id="2-1-输入坐标的划分"><a href="#2-1-输入坐标的划分" class="headerlink" title="2.1 输入坐标的划分"></a>2.1 输入坐标的划分</h3><p>给定一个二维坐标（x, y），你首先需要确定它所在的网格单元。通常情况下，柏林噪声会将空间划分为许多格点（也称为 <strong>格点阵列</strong>）。</p><h3 id="2-2-格点的随机值生成"><a href="#2-2-格点的随机值生成" class="headerlink" title="2.2 格点的随机值生成"></a>2.2 格点的随机值生成</h3><p>每个格点都有一个固定的随机值（在一些实现中是随机方向的向量）。这意味着你并不是直接生成每个点的噪声，而是通过格点周围的随机值来进行插值计算。</p><h3 id="2-3-平滑插值"><a href="#2-3-平滑插值" class="headerlink" title="2.3 平滑插值"></a>2.3 平滑插值</h3><p>对于输入坐标点（x, y），找到它所属的格点，并通过 <strong>插值</strong>（通常是 <strong>线性插值</strong> 或 <strong>余弦插值</strong>）计算该点的噪声值。插值确保了在格点之间的变化是平滑的。</p><h3 id="2-4-梯度（Gradient）和向量插值"><a href="#2-4-梯度（Gradient）和向量插值" class="headerlink" title="2.4 梯度（Gradient）和向量插值"></a>2.4 梯度（Gradient）和向量插值</h3><p>每个格点都有一个<strong>随机梯度</strong>，即一个随机的方向向量。通过计算输入点与格点之间的相对向量与该格点的梯度之间的点积来得到噪声值。这些值再通过插值来平滑过渡。</p><h3 id="2-5-多频率噪声叠加"><a href="#2-5-多频率噪声叠加" class="headerlink" title="2.5 多频率噪声叠加"></a>2.5 多频率噪声叠加</h3><p>为了增强噪声的细节和复杂性，通常会叠加多个不同频率（缩放比例）和振幅的噪声层。这种方法被称为 <strong>Octaves</strong>（八度）。每个“八度”会产生一种不同尺度的噪声。</p><hr><h2 id="3-噪声地图"><a href="#3-噪声地图" class="headerlink" title="3.噪声地图"></a>3.噪声地图</h2><p>Unity提供了方便的工具类可以直接使用用于生成噪声地图</p><h3 id="3-1-Noise-类：生成柏林噪声地图"><a href="#3-1-Noise-类：生成柏林噪声地图" class="headerlink" title="3.1 Noise 类：生成柏林噪声地图"></a>3.1 <code>Noise</code> 类：生成柏林噪声地图</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Noise</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span>[,] GenerateNoiseMap(<span class="built_in">int</span> mapWidth, <span class="built_in">int</span> mapHeight, <span class="built_in">float</span> scale)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个二维数组，用于存储噪声地图</span></span><br><span class="line">        <span class="built_in">float</span>[,] noiseMap = <span class="keyword">new</span> <span class="built_in">float</span>[mapWidth, mapHeight];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果比例值scale小于等于0，设置为一个非常小的值，以防止除零或无效的噪声生成</span></span><br><span class="line">        <span class="keyword">if</span> (scale &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            scale = <span class="number">0.0001f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历地图的每个像素（从y到x）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; mapHeight; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; mapWidth; x++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 计算每个像素的X和Y采样坐标</span></span><br><span class="line">                <span class="built_in">float</span> sampleX = x / scale;</span><br><span class="line">                <span class="built_in">float</span> sampleY = y / scale;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用Perlin噪声函数来生成噪声值</span></span><br><span class="line">                <span class="built_in">float</span> perlinValue = Mathf.PerlinNoise(sampleX, sampleY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将生成的噪声值赋值给对应的噪声地图位置</span></span><br><span class="line">                noiseMap[x, y] = perlinValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noiseMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul><li><code>GenerateNoiseMap</code> 方法是生成噪声地图的核心。它会根据输入的 <code>mapWidth</code>、<code>mapHeight</code> 和 <code>scale</code> 生成一个二维的噪声图。</li><li><code>Mathf.PerlinNoise(sampleX, sampleY)</code> 是 Unity 内置的函数，用于生成一个在 [0, 1] 范围内的柏林噪声值。<code>scale</code> 控制噪声的细节：较大的 <code>scale</code> 会生成平滑的噪声，而较小的 <code>scale</code> 会生成细节更多的噪声。</li></ul><h3 id="3-2-MapGenerator类：调用噪声生成器并显示地图"><a href="#3-2-MapGenerator类：调用噪声生成器并显示地图" class="headerlink" title="3.2 MapGenerator类：调用噪声生成器并显示地图"></a>3.2 <code>MapGenerator</code>类：调用噪声生成器并显示地图</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MapGenerator</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> mapWidth;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> mapHeight;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> mapScale;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> autoUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GenerateMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成噪声地图</span></span><br><span class="line">        <span class="built_in">float</span>[,] noiseMap = Noise.GenerateNoiseMap(mapWidth, mapHeight, mapScale);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到 MapDisplay 组件并显示噪声地图</span></span><br><span class="line">        MapDisplay display = FindAnyObjectByType&lt;MapDisplay&gt;();</span><br><span class="line">        display.DrawNoiseMap(noiseMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h4><ul><li><code>GenerateMap</code> 方法调用 <code>Noise.GenerateNoiseMap</code> 来生成一个噪声地图，并将其传递给 <code>MapDisplay</code> 类的 <code>DrawNoiseMap</code> 方法，渲染到屏幕上。</li><li><code>autoUpdate</code> 是一个标志，如果为 <code>true</code>，在每次修改参数后会自动更新地图。</li></ul><h3 id="3-3-MapDisplay-类：渲染噪声地图到纹理"><a href="#3-3-MapDisplay-类：渲染噪声地图到纹理" class="headerlink" title="3.3 MapDisplay 类：渲染噪声地图到纹理"></a>3.3 <code>MapDisplay</code> 类：渲染噪声地图到纹理</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MapDisplay</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Renderer textureRender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawNoiseMap</span>(<span class="params"><span class="built_in">float</span>[,] noiseMap</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> width = noiseMap.GetLength(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">int</span> height = noiseMap.GetLength(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Texture2D texture = <span class="keyword">new</span> Texture2D(width, height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 储存一个大小为 width * height 的颜色数据，每个索引对应一个像素</span></span><br><span class="line">        Color[] colourMap = <span class="keyword">new</span> Color[width * height];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; height; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; width; x++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将噪声值从 [0, 1] 映射到黑白颜色</span></span><br><span class="line">                colourMap[y * width + x] = Color.Lerp(Color.black, Color.white, noiseMap[x, y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将颜色数据应用到纹理</span></span><br><span class="line">        texture.SetPixels(colourMap);</span><br><span class="line">        texture.Apply();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将生成的纹理设置到材质</span></span><br><span class="line">        textureRender.sharedMaterial.mainTexture = texture;</span><br><span class="line">        textureRender.transform.localScale = <span class="keyword">new</span> Vector3(width, <span class="number">1</span>, height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释：-2"><a href="#解释：-2" class="headerlink" title="解释："></a>解释：</h4><ul><li><code>DrawNoiseMap</code> 方法负责将生成的噪声地图渲染为纹理并应用到指定的材质上。</li><li><code>Color.Lerp(Color.black, Color.white, noiseMap[x, y])</code>：使用线性插值函数 <code>Lerp</code> 将噪声值映射为黑白色调。噪声值越接近 1，颜色越白；越接近 0，颜色越黑。</li><li><code>texture.SetPixels(colourMap)</code> 和 <code>texture.Apply()</code> 将颜色数据应用到纹理上，然后显示出来。</li></ul><hr><h3 id="3-4-自定义编辑器（NewBehaviourScript-类）"><a href="#3-4-自定义编辑器（NewBehaviourScript-类）" class="headerlink" title="3.4 自定义编辑器（NewBehaviourScript 类）"></a>3.4 自定义编辑器（<code>NewBehaviourScript</code> 类）</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CustomEditor(typeof(MapGenerator))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MapGenerator mapGen = (MapGenerator)target;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DrawDefaultInspector())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 自动更新地图</span></span><br><span class="line">            <span class="keyword">if</span> (mapGen.autoUpdate)</span><br><span class="line">            &#123;</span><br><span class="line">                mapGen.GenerateMap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动生成按钮</span></span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;Generate&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            mapGen.GenerateMap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释：-3"><a href="#解释：-3" class="headerlink" title="解释："></a>解释：</h4><ul><li>这是一个自定义编辑器，用来控制 Unity Inspector 中的行为。</li><li><code>GUILayout.Button(&quot;Generate&quot;)</code> 创建一个按钮，点击后调用 <code>mapGen.GenerateMap()</code> 生成地图。</li><li>如果 <code>autoUpdate</code> 为 <code>true</code>，则在参数更改时自动更新地图。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分层四元法框架学习</title>
      <link href="/2024/09/04/fen-ceng-si-yuan-fa/"/>
      <url>/2024/09/04/fen-ceng-si-yuan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="分层四元法"><a href="#分层四元法" class="headerlink" title="分层四元法"></a>分层四元法</h1><p>​分层四元法是在《游戏设计，原型与开发》中提出的一个分析框架，分层四元法提出了四种元素（机制，美学，技术和叙事），再由三个层次表现这些游戏设计元素。三层分别为内嵌层，动态层和文化层。</p><h2 id="内嵌层"><a href="#内嵌层" class="headerlink" title="内嵌层"></a>内嵌层</h2><h3 id="机制内嵌"><a href="#机制内嵌" class="headerlink" title="机制内嵌"></a>机制内嵌</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>​游戏的最终目标一般是为了“获胜”，但在具体的游戏过程中会有多个小目标，玩家会根据轻重缓急权衡数个目标。因此在设计游戏的过程中我们要注意<strong>游戏目标的紧迫性</strong>对玩家的影响而设计出类似短期目标，中期目标的分类。</p><p>​除了紧迫性之外，不同<strong>目标的重要程度</strong>也是多样的。例如RPG游戏中的主线任务与支线任务，不同的玩家对待支线任务的态度或许是截然不同的。</p><p>​作为玩家我经常遇到<strong>目标之间的冲突情况</strong>，例如在《文明六》中我可以消耗金钱来建造区域或生成军队，此时建造区域和生成军队两个任务就会由于金钱资源的有限发生冲突。再比如《大富翁》的游戏最终目标是获取最多的金钱，但在游戏过程中必须花费金钱投资地产。在游戏中有利有弊的各种选择带来了很多的乐趣。</p><p>​综上，在设计游戏时我们要综合游戏目标的紧迫性，重要程度和各目标间的冲突来设计出尽量符合我们目的的游戏体验。</p><h4 id="玩家关系"><a href="#玩家关系" class="headerlink" title="玩家关系"></a>玩家关系</h4><p>​ <code>玩家的目标决定了玩家关系</code>。无论是单人游戏，多人合作游戏，多人对抗游戏还是其它任何的玩家关系模式，本质上都是由游戏中所有玩家目标的组合决定的。这点十分好理解故不做记录。</p><h4 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h4><p>​我们都知道在设计游戏的过程中经常需要负责创造空间，为了设计得足够好要记住以下要点：</p><ul><li>空间的目的</li><li>流程：空间是适合玩家通过还是限制玩家行动？设计的动机是什么？基于这些改进我们的空间设计为玩家的游玩过程提供服务。</li><li>地标：在虚拟的3D空间中记住地形比现实中更困难，因此我们可以设置地标帮助玩家认路。</li><li>短，中，长期目标：在开放世界中可能会在游戏初期遇到高级敌人，激励玩家先去探索其它区域在之后再击败他了。在《方舟：生存进化》中世界也被分为了更适合游戏初期的简单区域和生存压力较大的困难区域。</li></ul><p>另外最近我正在玩《黑神话：悟空》，毫无疑问这是一款不完美的好游戏。我认为黑猴在空间的设计上有一处不合理就是道路的两边太像难以区分，因此在游玩过程中找路就成了一个不够好的体验。再加上游戏或许是为了更好的美术视觉体验经常有一些看似能走但实际上被粗暴的空气墙挡住的区域以及没有内置地图，导致我一个自认为方向感不错的人也稍微有点小路痴了。但<strong>黑猴还是真他妈的好玩</strong>，嘿嘿。</p><p>其余还有规则，边界，资源等概念不做解释</p><hr><h2 id="动态层"><a href="#动态层" class="headerlink" title="动态层"></a>动态层</h2><hr><h2 id="文化层"><a href="#文化层" class="headerlink" title="文化层"></a>文化层</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏分析框架基础</title>
      <link href="/2024/09/03/you-xi-fen-xi-kuang-jia/"/>
      <url>/2024/09/03/you-xi-fen-xi-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="经典游戏分析框架"><a href="#经典游戏分析框架" class="headerlink" title="经典游戏分析框架"></a>经典游戏分析框架</h1><h2 id="MDA框架"><a href="#MDA框架" class="headerlink" title="MDA框架"></a>MDA框架</h2><p>机制（mechanics），动态（dynamics），美学（aesthetics）</p><p>​首先我们要知道不同的框架中或许都分别提到了同一词汇，例如在四元法框架中同样提到了机制与美学。但这些框架对这同一词汇的定义不尽相同，因此我们要分别理解其中的理念。以下是在MDA中的定义：</p><ul><li>机制：游戏的数据层面上的组件和算法</li><li>动态：相应玩家输入和其他输出的实时行为</li><li>美学：玩家与游戏系统交互时，应当唤起的情绪反应</li></ul><p>​MDA认为游戏设计师应当最先确定想要玩家感受到的美学，再逆向设计机制与动态。在《游戏设计，原型与开发》中提到了桌游《蛇与梯子》作为一款低龄向桌游《蛇与梯子》的美学是希望，形势逆转以及完全不做选择的刺激，以此设计出蛇（负反馈）和梯子（正反馈）的机制。游戏玩法是投掷骰子进行移动，在地图上踩到蛇或梯子时有相应的前进和后退，是一款完全凭借运气取胜的游戏。<code>（飞行棋是不是也完全依赖运气，无策略性？）</code></p><h2 id="FDD框架"><a href="#FDD框架" class="headerlink" title="FDD框架"></a>FDD框架</h2><p>形式，戏剧和动态元素</p><ul><li>形式：包括规则，资源和界限</li><li>戏剧：剧情和叙事，设定</li><li>动态：类似MDA中的动态</li></ul><h5 id="形式元素"><a href="#形式元素" class="headerlink" title="形式元素"></a>形式元素</h5><p>​在《游戏设计梦工厂》中提出了游戏的7中形式元素：</p><ol><li>玩家交互模式</li><li>目标</li><li>规则</li><li>过程：玩家在游戏中的行动</li><li>资源：有价值的各种元素，例如金钱和血量</li><li>边界</li><li>结局</li></ol><h5 id="戏剧元素"><a href="#戏剧元素" class="headerlink" title="戏剧元素"></a>戏剧元素</h5><p>前提，角色，戏剧</p><p>关于角色：由于在游戏中主角就是玩家扮演的角色，通常我们需要决定是让主角作为玩家的代言人还是让玩家扮演一个角色。</p><p>戏剧是游戏的请假，包含了整个游戏过程的叙事内容，前提是戏剧展示的舞台（例如故事背景）。</p><h5 id="动态元素"><a href="#动态元素" class="headerlink" title="动态元素"></a>动态元素</h5><p>指在游戏过程中发生变化的东西，核心为简单规则的碰撞可以导致难以预期的结果，试玩是理解动态的唯一方法。</p><h2 id="四元法"><a href="#四元法" class="headerlink" title="四元法"></a>四元法</h2><p>在《游戏设计艺术》中提出的四元法框架：机制，美学，技术，剧情</p><p>通过了解前两种框架我们大概也能明白四元法的理念，但值得注意的是四元法中的美学指的是直观的游戏如何被五感接受，而MDA中更倾向于指游戏触动的人的情绪。</p><hr><p>此外，在《游戏设计，原型与开发》中提出了一个结合了上述三种分析框架的新框架<a href="/2024/09/04/fen-ceng-si-yuan-fa/" title="分层四元法框架学习">分层四元法框架学习</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNITY引擎基础-01</title>
      <link href="/2024/07/15/unity-yin-qing-ji-chu/"/>
      <url>/2024/07/15/unity-yin-qing-ji-chu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> UNITY </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识游戏设计</title>
      <link href="/2024/04/16/chu-shi-you-xi-she-ji/"/>
      <url>/2024/04/16/chu-shi-you-xi-she-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="初识游戏设计"><a href="#初识游戏设计" class="headerlink" title="初识游戏设计"></a>初识游戏设计</h2><h2 id="24-4-17来自游戏设计与原型开发"><a href="#24-4-17来自游戏设计与原型开发" class="headerlink" title="24&#x2F;4&#x2F;17来自游戏设计与原型开发"></a>24&#x2F;4&#x2F;17来自游戏设计与原型开发</h2><h4 id="Bartok：游戏练习"><a href="#Bartok：游戏练习" class="headerlink" title="Bartok：游戏练习"></a>Bartok：游戏练习</h4><p>Bartok是一种类似Uno的桌游<em>（我爱Uno）</em></p><ol><li>准备一副去掉了大小王的扑克牌，洗混后向每个玩家发7张牌，剩下的牌面朝下作抽牌堆，将顶部的牌抽出一张牌面朝上作弃牌堆。</li><li>顺时针进行游戏，如果可以出牌必须出牌，如果不能出牌则必须抽一张牌</li><li>出牌条件如下:<ol><li>花色与弃牌堆顶部一致</li><li>数字与弃牌堆顶部一致</li></ol></li><li>出完手牌获胜</li></ol><p><em>（这不纯Uno基础版）</em></p><p><strong>重点在于</strong>试玩后分析游戏体验</p><ol><li>游戏难度对于目标受众是否合适</li><li>游戏结果靠运气or策略？随机性的占比是否恰当</li><li>当一方占上风是否导致直接锁定胜局，难以翻盘</li><li>玩家的乐趣是否只在自己的回合内，各玩家的回合操作之间有无影响<em>（大哥别卡我牌行吗）</em></li></ol><p>当我们收获了不同的游戏体验后就改针对性修改游戏了，所以游戏设计是一个<strong>增加，测试，分析，修改</strong>的过程多次重复直到设计师满意的过程。</p><p>在游戏设计与原型开发中提出了几个对Bartok规则的修改试玩的例子，例如如果一名玩家打出数字2，下一位玩家必须抽两张牌并跳过出牌。Uno玩家应该感到很熟悉，有一说一迭代设计真特么伟大。我相信大家都认同<strong>即使是简单的变动也能带来巨大的改变</strong>。</p><p>修改游戏设计过程中我们一般遵循以下几个原则：</p><ul><li>每次试玩只更改一条规则，为了分辨每个改变带来的影响</li><li>改动越大，就需要越多的试玩体验，以免被随机性蒙蔽</li><li>不要忽视小改动，再小的改动都可能彻底影响游戏</li></ul><h4 id="什么是游戏？"><a href="#什么是游戏？" class="headerlink" title="什么是游戏？"></a>什么是游戏？</h4><p>在《游戏设计，原型与开发》中有各路大神对游戏的定义，以及我们为什么要关注游戏的定义。</p><p>不过我读完觉得去他妈的，无所谓所以这段不作记录。</p><p>不过还是有些收获，首先人类喜欢设计好的冲突，人类想要成为别人，人类想要刺激。以上三点是游戏行业能吃上饭的基础，当我们设计游戏时也应该记住这些。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
